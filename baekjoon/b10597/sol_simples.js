let A = require('fs').readFileSync(0).toString().trim(); // 입력으로 주어진 문자열
let N=1; // 순열의 크기. 아직 순열의 크기를 모르기 때문에 1로 초기화함.
for (let n=0; ; ++N) { // ++N 하면서 순열의 크기를 찾는다
  // n: 순열을 공백 없이 이어붙인 문자열의 크기
  // N: N은 1번부터 시작하는 순열의 순열의 크기이자 가장 큰 수이다
  n += N<10 ? 1 : 2; // 가장 큰 수가 9 이하라면, n은 1 증가하고 10 이상이면 2 증가한다
  if (n >= A.length) break; // n이 입력 문자열의 크기와 일치할 때의 N이 순열의 크기이다
}
let S=[]; // 지금까지 선택한 수 목록
let V=[]; // 숫자 i를 선택했는지 표시하기 위한 배열. 중복 선택을 막기 위함
let 답;
DFS(0);
console.log(답);

function DFS(i) { // i: A 문자열에서의 현재 위치 인덱스
                  // 지금까지 선택한 S 순열은, A 문자열에서 인덱스 i 직전까지 일치한다
  if (i>=A.length) { // 문자열 끝까지 일치했다면
    답 = S.join(' '); // S 순열이 답이다
    return true; // 답을 찾았으니 리턴 true
  }

  // 지금까지 선택한 S 순열은, A 문자열에서 인덱스 i 직전까지 일치한다
  // 인덱스 i부터 시작하는 다양한 크기의 부분 문자열 각각에 대해서 반복 시도한다
  for (let j = i+1; j <= A.length; ++j) {
    let x = parseInt(A.slice(i, j)); // 인덱스 i 부터 j 직전까지의 부분문자열을 정수로 변환
    if (x > N) break; // N은 1부터 시작하는 순열의 크기이자 가장 큰 수이다
                   // x가 N 보다 크다면 순열에 포함된 수가 아니다
                   // x보다 더 긴 부분문자열 정수도 순열에 포함된 수가 아닐 테니 break

    if (x > 0 && !V[x]) { // x가 0이 아니고, x를 아직 선택하지 않았다면 (0도 순열에 포함된 수가 아님)
      V[x] = true;  // x를 선택했다고 표시
      S.push(x);    // x를 S 순열에 추가
      if (DFS(j)) return true; // 재귀호출. S 순열은 A 문자열에서 j직전 까지 일치한다.
                               // 재귀호출이 답을 찾았다고 리턴하면, 여기서도 바로 즉시 리턴 true
      V[x] = false; // 재귀호출에서 리턴하자 마자, x 선택을 취소한다
      S.pop();
    }
  }
  return false;
}