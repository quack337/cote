()()()() 1111
(()()()) 1222
(((()))) 1234
((()())) 1233
(()()()) 1222
((())()) 1232
((()))() 1231


다음 수 +1, 0, -1 .. -p까지

=1자리
1

=2자리
12
11

=3자리
123
122
121
112
111

=4자리
1234
1233
1232
1231
1223
1222
1221
1212
1211
1123
1122
1121
1112
1111

$ node sol1.js
2 1
4 2
6 5
8 14
10 42
12 132
14 429
16 1430
18 4862
20 16796

** sol6.js를 보면서 수열 끝자리만 정리함
N=L/2

N=1일 때, 수열 끝자리 BT(1)
1

N=2일 때, 수열 끝자리 BT(2)
2 1

N=3일 때, 수열 끝자리 BT(3)
3 2 1
2 1

N=4일 때.. 수열 끝자리를 보면 BT(4)
4 3 2 1
3 2 1
2 1

3 2 1
2 1

N=5 일 때 BT(5)
5 4 3 2 1
4 3 2 1
3 2 1
2 1 -- 14

4 3 2 1
3 2 1
2 1 -- 9

3 2 1
2 1 -- 5

4 3 2 1
3 2 1
2 1 -- 9

3 2 1
2 1 --5 == 42

N=6 일 때 BT(6)
6 5 4 3 2 1
5 4 3 2 1
4 3 2 1
3 2 1
2 1 -- 20

5 4 3 2 1
4 3 2 1
3 2 1
2 1 -- 14 = 34

4 3 2 1
3 2 1
2 1 -- 9 = 43

3 2 1
2 1 -- 5 = 48

5 4 3 2 1
4 3 2 1
3 2 1
2 1 -- 14 = 62

4 3 2 1
3 2 1
2 1 -- 9 = 71

3 2 1
2 1 -- 5 = 76

**** 아하!!
BT(1) = 1
BT(2) = 2
BT(3) = 5
BT(4) = 4+3+2 + BT(3) = 14
BT(5) = 5+4+3+2 + BT(4) =


- - - - - - sol7.js
sol6.js 출력을 보고 점화식 만들기
M[n][i] = 뒤에 n개 남았고, 현재 자리 수가 i

M[0][*] = 1   // max(i)=N
M[n][i] = sum(M[n-1][i+1] .. M[n-1][1]) // max(i)=N-n

- - - - - -  sol8.js
M[n][1] = M[n-1][2]+M[n-1][1];
M[n][i] = M[n][i-1]+M[n-1][i+1] // i: 2..N-n
